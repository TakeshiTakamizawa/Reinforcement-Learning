int epsilon_greedy(int epsilon, int s, int num_a, double Qtabl[][3]);
int select_action(int s, int num_a, double Qtabl[][3]);
double max_Qval(int s, int num_a, double Qtabl[][3]);
double get_reward();
int get_state();
void move(int a);


void main(void)
{
	const BYTE MainCycle = 60;
	
	
	int sw;
	
	int num_a = 3;//行動の数
	int num_s = 4;//状態の数
	double Qtable[4][3];
	
	double Q_max = 0;//Ｑ値の最大値
	double reward = 0; //報酬
	double alpha = 0.5;//学習係数
	double gamma = 0.9;//減衰係数
	int epsilon = 5;//行動を無作為に選ぶ確率[%]
	int trial_max = 1000;//試行回数

	int a = 0;//行動
	int s = 0;//状態
	int sd = 0;//行動の実行によって遷移する状態
	int i, j;
	int seed =0;

	Init((BYTE)MainCycle);		//CPUの初期設定
	I2C_init();			//IXBUS初期化

	
	//Q値の初期化
	for(i=0;i<num_s;i++){
		for(j=0;j<num_a;j++){
			Qtable[i][j]=0;
		}
	}
	
	//乱数の初期化
	while(!getSW()){
		LED(3);//初期化待ちの間はLEDが両方点灯
		seed++;
		if (seed > 1000){
			 seed=0;
		}
	}
	srand(seed);
	LED(0);//初期化が終わるとLEDを消灯
		
	//初期状態の観測
	s=get_state();
			
	//試行開始
	for (i = 0; i<trial_max; i++) {
		Sync();
		//行動の選択
		a = epsilon_greedy(epsilon, s, num_a, Qtable);
		//行動の実行
		move(a);
		//状態の観測
		sd=get_state();
		reward=get_reward();
		
		//sdにおけるＱ値の最大値を求める
		Q_max = max_Qval(sd, num_a, Qtable);
		//Ｑ値の更新
		Qtable[s][a] = (1 - alpha) * Qtable[s][a] + alpha * (reward + gamma * Q_max);
		
		s = sd;
			
		if(reward<0){
			s=0;
			Mtr_Run_lv(0,0,0,0,0,0);
			while(!getSW()){
				LED(3);
				Wait(200);
				LED(0);
				Wait(200);
			}
			s=get_state();
		}
	}
		
	while(1){
		//獲得されて政策を実行
		Sync();
		s=get_state();
		a = select_action(s, num_a, Qtable);
		move(a);
	}
}

void move(int a){
	
	if (a==0){
		
		Mtr_Run(-45,35,0,0);//前進
	}
	else if(a==1){
		Mtr_Run(0,35,0,0);//右回転
	}
	else{
		Mtr_Run(-45,0,0,0);//左回転
	}
	
}

int get_state(){
	unsigned int data[8];
	int s;
	Get_IX008(0x90,data);
	
	s=3; //下記以外のとき
		
	if( data[1]>300||data[2]>300){
		s=1; //右のセンターが反応
		
		BuzzerSet(220,0x80);
		BuzzerStart();
		Wait(50);
		BuzzerStop();
	}
	else if(data[6]>300||data[5]>300 ){
		s=2; //左のセンターが反応
		
		BuzzerSet(110,0x80);
		BuzzerStart();
		Wait(50);
		BuzzerStop();
	}
	else if(data[4]>300||data[3]>300 ){
		s=0;//中心のセンターが反応
		BuzzerStop();
	}
	return s;
}



double get_reward(){
	unsigned int data[8];
	double reward;
	
	Get_IX008(0x90,data);
	
	reward=0; 
			
	if (data[0]>300 || data[7]>300){  
		reward=-100;
		LED(1);
	}
	else if (data[3]>300 || data[4]>300){
		reward=1; 
		LED(2);
	}
	else{
		 LED(0);
	}
	return reward;
}


int select_action(int s, int num_a, double Qtable[][3]) {
	double max;
	int i = 0;
	int i_max;
	int a;

	max = Qtable[s][0];
	i_max=0;

	for (i = 1; i<num_a; i++) {
		if (Qtable[s][i]>max) {
			max = Qtable[s][i];
			i_max = i;
		}
	
	}

	a = i_max;
	return a;
}


int epsilon_greedy(int epsilon, int s, int num_a, double Qtable[][3]) {
	int a;
	if (epsilon > rand() % 100) {
		//無作為に行動を選択
		a = rand() % num_a;
		

	
	}
	else {
		//最大のＱ値を持つ行動を選択
		a = select_action(s, num_a, Qtable);
		
	}
	return a;

}	


double max_Qval(int s, int num_a, double Qtable[][3]) {
	double max;
	int i = 0;

	max = Qtable[s][0];
	for (i = 1; i<num_a; i++) {
		if (Qtable[s][i]>max) {
			max = Qtable[s][i];
		}
	}
	return max;
}

